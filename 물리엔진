// main.c

#include <stdio.h>
#include <stdlib.h> // rand() 사용
#include <SDL2/SDL.h>
#include "physics_engine.h" // 물리 엔진 헤더 포함
#include <math.h>         // M_PI 사용을 위해

// --- SDL 및 화면 설정 ---
#define SCREEN_WIDTH 800
#define SCREEN_HEIGHT 600

SDL_Window* g_window = NULL;
SDL_Renderer* g_renderer = NULL;

// --- 헬퍼 함수: 월드 좌표 -> 화면 좌표 ---
Vector2 world_to_screen(Vector2 world_pos, CarState* car) {
    Vector2 rel_pos = { world_pos.x - car->position.x, world_pos.y - car->position.y };
    float s = sinf(-car->yaw_angle);
    float c = cosf(-car->yaw_angle);
    
    // 차량 기준 상대 좌표
    Vector2 rotated_pos = { rel_pos.x * c - rel_pos.y * s, 
                            rel_pos.x * s + rel_pos.y * c };
    
    // 화면 좌표로 변환
    float screen_x = -rotated_pos.y + SCREEN_WIDTH / 2.0f;
    float screen_y = -rotated_pos.x + SCREEN_HEIGHT / 2.0f;
    
    return (Vector2){ screen_x, screen_y };
}

// --- SDL 초기화 ---
int init_sdl() {
    if (SDL_Init(SDL_INIT_VIDEO) < 0) return 0;
    g_window = SDL_CreateWindow("Fixed Car, Moving World (Grid)", SDL_WINDOWPOS_UNDEFINED, 
                                SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, 0);
    if (!g_window) return 0;
    g_renderer = SDL_CreateRenderer(g_window, -1, SDL_RENDERER_ACCELERATED);
    if (!g_renderer) return 0;
    
    return 1;
}

// --- 입력 처리 ---
void handle_input(InputState* input, int* running) {
    SDL_Event e;
    while (SDL_PollEvent(&e)) {
        if (e.type == SDL_QUIT) *running = 0;
    }
    const Uint8* keystate = SDL_GetKeyboardState(NULL);
    input->throttle = 0.0f;
    if (keystate[SDL_SCANCODE_UP]) input->throttle = 1.0f;
    if (keystate[SDL_SCANCODE_DOWN]) input->throttle = -1.0f;
    input->steering = 0.0f;
    if (keystate[SDL_SCANCODE_LEFT]) input->steering = 1.0f; 
    if (keystate[SDL_SCANCODE_RIGHT]) input->steering = -1.0f; 
}

// --- 렌더링 ---
void render(CarState* car) {
    SDL_SetRenderDrawColor(g_renderer, 0, 0, 0, 255);
    SDL_RenderClear(g_renderer);

    // 가상 격자(Virtual Grid) 렌더링
    SDL_SetRenderDrawColor(g_renderer, 0, 150, 0, 255); // 격자점 색상

    const float GRID_SIZE = 100.0f; // 격자 간격
    const float RENDER_DISTANCE = 1500.0f; // 렌더링 거리

    float car_x = car->position.x;
    float car_y = car->position.y;
    
    float x_start = floorf((car_x - RENDER_DISTANCE) / GRID_SIZE) * GRID_SIZE;
    float x_end   = ceilf((car_x + RENDER_DISTANCE) / GRID_SIZE) * GRID_SIZE;
    float y_start = floorf((car_y - RENDER_DISTANCE) / GRID_SIZE) * GRID_SIZE;
    float y_end   = ceilf((car_y + RENDER_DISTANCE) / GRID_SIZE) * GRID_SIZE;

    for (float y = y_start; y <= y_end; y += GRID_SIZE) {
        for (float x = x_start; x <= x_end; x += GRID_SIZE) {
            
            Vector2 grid_world_pos = {x, y};
            Vector2 screen_pos = world_to_screen(grid_world_pos, car);

            if (screen_pos.x < 0 || screen_pos.x > SCREEN_WIDTH || 
                screen_pos.y < 0 || screen_pos.y > SCREEN_HEIGHT) {
                continue;
            }
                
            SDL_Rect grid_point = { (int)screen_pos.x - 1, (int)screen_pos.y - 1, 3, 3 }; // 3x3 점
            SDL_RenderFillRect(g_renderer, &grid_point);
        }
    }

    // 차량 렌더링
    SDL_Rect car_rect = { SCREEN_WIDTH / 2 - 10, SCREEN_HEIGHT / 2 - 20, 20, 40 };
    SDL_SetRenderDrawColor(g_renderer, 255, 0, 0, 255);
    SDL_RenderFillRect(g_renderer, &car_rect);

    SDL_RenderPresent(g_renderer);
}

// --- 메인 함수 ---
int main(int argc, char* argv[]) {
    if (!init_sdl()) {
        printf("SDL 초기화 실패!\n");
        return -1;
    }

    CarParameters params;
    CarState state;
    InputState input = {0};
    
    physics_init_parameters(&params);
    physics_init_state(&state);
    
    int running = 1;

    // ##################################################################
    // ### [수정됨] 타이핑 오류 수정 ###
    // ##################################################################
    Uint32 last_tick = SDL_GetTicks(); // Uint3Sint32 -> Uint32
    // ##################################################################

    while (running) {
        handle_input(&input, &running);
        
        Uint32 current_tick = SDL_GetTicks();
        float dt = (current_tick - last_tick) / 1000.0f;
        last_tick = current_tick;
        
        if (dt > 0.05f) dt = 0.05f; 
        
        physics_update(&state, &params, &input, dt);
        
        render(&state);
        
        SDL_Delay(16);
    }

    SDL_DestroyRenderer(g_renderer);
    SDL_DestroyWindow(g_window);
    SDL_Quit();
    return 0;
}
