// physics_engine.c

#include "physics_engine.h"
#include <math.h> // sinf, cosf, atan2f, fabsf, M_PI
#include <stdio.h> 

// --- 내부 헬퍼 함수 프로토타입 ---
Vector2 v_rotate(Vector2 v, float angle);

// --- 간단한 벡터/수학 헬퍼 함수 ---
Vector2 v_rotate(Vector2 v, float angle) {
    float c = cosf(angle);
    float s = sinf(angle);
    return (Vector2){ v.x * c - v.y * s, v.x * s + v.y * c };
}

// ----------------------------------

void physics_init_parameters(CarParameters* params) {
    params->mass = 1200.0f;
    params->Iz = 3000.0f;
    params->cornering_stiffness = 100000.0f;
    params->Lf = 1.2f;
    params->Lr = 1.3f;
    params->max_motor_torque = 8100.0f;
    params->wheel_radius = 0.3f;
    params->max_grip_force = 10000.0f;
    params->drag_constant = 15.0f;
    
    // [추가됨] 미끄러질 때의 마찰력은 최대 마찰력의 80%로 설정
    params->sliding_friction_factor = 0.8f; 
}

void physics_init_state(CarState* state) {
    state->position = (Vector2){ 0.0f, 0.0f };
    state->velocity = (Vector2){ 0.0f, 0.0f };
    state->yaw_angle = M_PI / 2.0f; // 위쪽(Y축 양) 방향
    state->yaw_rate = 0.0f;
}

// ##################################################################
// ### [수정됨] 비선형 타이어 마찰 모델 계산 함수 ###
// ##################################################################
float calculate_non_linear_fy(float alpha, const CarParameters* params) {
    // 1. 파라미터 정의
    float C_stiffness = params->cornering_stiffness;
    float F_peak = params->max_grip_force;
    
    // 2. 미끄러짐 마찰력 계산
    float F_slide = F_peak * params->sliding_friction_factor;
    
    // 3. 최대 그립(F_peak)이 발생하는 슬립각 계산 (alpha_peak)
    // (선형 모델에서 F_peak = C_stiffness * alpha_peak 이므로)
    float alpha_peak = F_peak / C_stiffness;
    
    float Fy;
    
    // 4. 슬립각의 절대값으로 비교
    float alpha_abs = fabsf(alpha);
    float sign = (alpha > 0) ? 1.0f : -1.0f; // 힘의 방향

    if (alpha_abs < alpha_peak) {
        // A. 그립 영역 (선형 증가): Fy = C * alpha
        Fy = -C_stiffness * alpha;
    } else {
        // B. 슬립 영역 (미끄러짐): Fy = F_slide
        // (더 복잡한 모델은 여기서부터 떨어지는 곡선을 그리지만,
        //  일정한 미끄러짐 마찰력으로 유지하는 것이 더 간단하고 안정적입니다.)
        Fy = -F_slide * sign;
    }
    
    return Fy;
}
// ##################################################################


// 물리 업데이트 함수
void physics_update(CarState* state, const CarParameters* params, const InputState* input, float dt) {
    
    Vector2 v_local = v_rotate(state->velocity, -state->yaw_angle);
    float vx_local = v_local.x;
    float vy_local = v_local.y;

    float r = state->yaw_rate;
    float delta = input->steering * 0.25f; 

    float alpha_f, alpha_r;
    if (fabsf(vx_local) < 0.1f) {
        alpha_f = 0.0f; 
        alpha_r = 0.0f;
    } else {
        alpha_f = atan2f(vy_local + params->Lf * r, vx_local) - delta;
        alpha_r = atan2f(vy_local - params->Lr * r, vx_local);
    }

    // --- 3. 힘 계산 (비선형 모델 적용) ---
    // [수정됨] 횡력을 비선형 함수로 계산
    float Fy_f = calculate_non_linear_fy(alpha_f, params);
    float Fy_r = calculate_non_linear_fy(alpha_r, params);
    
    // (그립 한계 로직은 이제 calculate_non_linear_fy 내부로 통합됨)
    // if (Fy_f > params->max_grip_force) Fy_f = params->max_grip_force; ... (이전 로직 제거)
    
    // (후륜구동 RWD 가정)
    float Fx_f_motor = 0.0f; 
    float Fx_r_motor = (input->throttle * params->max_motor_torque) / params->wheel_radius;
    
    float Fx_drag = -params->drag_constant * vx_local;
    float Fy_drag = -params->drag_constant * vy_local;

    float cos_d = cosf(delta);
    float sin_d = sinf(delta);
    
    float F_total_local_x = (Fx_f_motor * cos_d - Fy_f * sin_d) + Fx_r_motor + Fx_drag;
    float F_total_local_y = (Fx_f_motor * sin_d + Fy_f * cos_d) + Fy_r + Fy_drag;
    float M_total_z = ( (Fx_f_motor * sin_d + Fy_f * cos_d) * params->Lf ) - ( Fy_r * params->Lr );

    Vector2 a_local = { F_total_local_x / params->mass, F_total_local_y / params->mass };
    float angular_accel = M_total_z / params->Iz;

    Vector2 a_world = v_rotate(a_local, state->yaw_angle);
    
    state->velocity.x += a_world.x * dt;
    state->velocity.y += a_world.y * dt;
    state->position.x += state->velocity.x * dt;
    state->position.y += state->velocity.y * dt;
    
    state->yaw_rate += angular_accel * dt;
    state->yaw_angle += state->yaw_rate * dt;
}
